---
layout: post
title: "[Algorithm] - 9. 프로그래머스 - 두 큐 합 같게 만들기"
subtitle:   "algorithm - 9. programmers "
categories: algorithm
tags: algorithm
comments: true
---



[코딩테스트 연습 - 두 큐 합 같게 만들기](https://school.programmers.co.kr/learn/courses/30/lessons/118667)

### 나의 풀이

---

나는 아래와 같이 풀었고 결국은 시간초과로 해결하지 못했다.

```jsx
function solution(queue1, queue2) {
  let q1Sum = sum(queue1);
  let q2Sum = sum(queue2);
  const length = queue1.length > queue2.length ? queue1.length : queue2.length;
  const target = (q1Sum + q2Sum) / 2;
  let count = 0;

  if((q1Sum + q2Sum) %2 === 1) return -1;

  while(count < length * 3) {

    if(q1Sum > q2Sum) {
      const temp = queue1.shift();
      q1Sum -= temp;
      q2Sum += temp;
      queue2.push(temp);
    } else if(q1Sum < q2Sum) {
      const temp = queue2.shift();
      q1Sum += temp;
      q2Sum -= temp;
      queue1.push(temp);
    } else {
      if(q1Sum === target) {
        return count;
      }
      return -1;
    }
    count += 1;
  }
  return -1;
}

function sum(q) {
  return q.reduce((total, current) => total + current, 0);
}
```

조금 찾아보니 js array의 push와 shift 연산의 비용이 크다는 이야기를 들었다.

어떻게 해결할지 찾아보니

아래와 같이 푼 코드를 발견하였다.

### 다른분의 풀이

---

[[프로그래머스] 두 큐 합 같게 만들기 JavaScript 투포인터](https://velog.io/@youngcheon/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%91%90-%ED%81%90-%ED%95%A9-%EA%B0%99%EA%B2%8C-%EB%A7%8C%EB%93%A4%EA%B8%B0)

```jsx
function solution(queue1, queue2) {
    const TOTAL_ARRAY = [...queue1, ...queue2];
    const MAXCOUNT = 4*TOTAL_ARRAY.length;
    const sum = (array)=>array.reduce((a,b)=>a+b);
    const TARGET = sum(TOTAL_ARRAY)/2;
    let count = 0;
    let start = 0;
    let end = queue1.length;
    let totalSum = sum(TOTAL_ARRAY.slice(start, end));
    while(count<=MAXCOUNT){
        if(TARGET > totalSum){
            totalSum += TOTAL_ARRAY[end];
            end++;
        }else if(TARGET < totalSum){
            totalSum -= TOTAL_ARRAY[start];
            start++;      
        }else if(TARGET === totalSum){
            return count;
        }
        count++;
    }
    return -1;
}
```

2개의 배열을 풀어놓고 pointer 변수인데 start , end로 sum을 구하는 방식이다.

실제로 실행시간을 비교해보았다.

```jsx
let array = Array(1000000)
  .fill()
  .map((e, i) => i);
function test() {
  let sum = 0;
  let test;
  for (var i of array.keys()) {
    sum += array.shift();
  }
}

function test2() {
  let sum = 0;
  for (var i of array.keys()) {
    sum += array[i];
  }
}

function test3() {
  const array2 = [];
  for (var i of array) {
    array2.push(i);
  }
}
console.log('연산 비교 스타트');
let start = new Date(); // 시작
test();
let end = new Date(); // 종료

console.log(`shift  연산 : ${end - start}`); // 경과시간(밀리초)

start = new Date(); // 시작
test2();
end = new Date(); // 종료
console.log(`index 접근 : ${end - start}`); // 경과시간(밀리초)

start = new Date(); // 시작
test3();
end = new Date(); // 종료
console.log(`push 연산 : ${end - start}`); // 경과시간(밀리초)
```

결과는 비교할 수 없을 만큼 차이가 났다

> shift 연산 : 117911 // 약 2분 
index 접근 : 10
push 연산 : 31
> 

앞으로 최대한 효율을 내야하는 코드에서는 shift연산은 조심해야할것 같다.

### 최종 수정 코드

---

```jsx
function solution(queue1, queue2) {
  let q1Sum = sum(queue1);
  let q2Sum = sum(queue2);
  const totalQueue = [...queue1, ...queue2];
  const length = queue1.length > queue2.length ? queue1.length : queue2.length;
  const target = (q1Sum + q2Sum) / 2;
  let count = 0;
  let start = 0;
  let end = queue1.length;

  if((q1Sum + q2Sum) %2 === 1) return -1;

  while(count < length * 3) {

    if(q1Sum > q2Sum) {
       
    
      const temp = totalQueue[start];
      q1Sum -= temp;
      q2Sum += temp;
      start++;
    } else if(q1Sum < q2Sum) {
        
      const temp = totalQueue[end];
      q1Sum += temp;
      q2Sum -= temp;
      end++;
    } else {
      if(q1Sum === target) {
        return count;
      }
      return -1;
    }
    count += 1;
  }
  return -1;
}

function sum(q) {
  return q.reduce((total, current) => total + current, 0);
}
```

나도 위와 같은 컨셉으로 수정하여 해결하였다.