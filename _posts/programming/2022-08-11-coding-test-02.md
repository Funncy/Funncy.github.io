---
layout: post
title: "[Algorithm] - 2. 프로그래머스 - 로또의 최고 순위와 최저 순위 "
subtitle:   "algorithm - 2. programmers "
categories: algorithm
tags: algorithm
comments: true
---

[코딩테스트 연습 - 로또의 최고 순위와 최저 순위](https://school.programmers.co.kr/learn/courses/30/lessons/77484)

일단 내가 푼 코드이다.

```jsx
function solution(lottos, win_nums) {
  //먼저 해야할 일
  // 1. 0 갯수 카운팅
  // 2. 나머지 번호에서 맞춘 번호 카운팅
  // 3. min + max 계산 해서 순위 반환
  
  const randomCount = lottos.reduce((count, obj) => { return obj === 0 ? count +1 : count }, 0);
  const matchNumbers = lottos.filter((e) => e !== 0).filter((e)=> win_nums.includes(e)
  );

  const matchCount = matchNumbers.length;

  const winCount = 6;
  const maxRate = winCount - matchCount - randomCount + 1;
  const minRate = winCount - matchCount + 1;

  const result = [maxRate > 6 ? 6:maxRate, minRate > 6 ? 6:minRate];
  return result;

}
```

처음에는 위와 같이 풀었다가 조금 더 고민해서 더 줄여볼 수 없을까 하다가 아래처럼 줄여보았다.

```jsx
function solution(lottos, win_nums) {
  //먼저 해야할 일
  // 1. 0 갯수 카운팅
  // 2. 나머지 번호에서 맞춘 번호 카운팅
  // 3. min + max 계산 해서 순위 반환
    
    const result = lottos.reduce((result, obj)=>{
        if(win_nums.includes(obj)) {
            result[0]--;
            result[1]--;
        }else if(obj === 0) {
            result[0]--;
        }
        return result;
    }, [7,7]);
  
    
  return [result[0] > 6 ? 6 : result[0] , result[1] > 6 ? 6 : result[1]];

}
```

사실 아래가 더 코드가 이해하기 어려운것 같다. 

그리고 약간 함정이 1개만 맞춰도 6등 0개여도 6등이여서

나는 이걸 result에서 삼항 연산자를 통해서 표현해주었다.

아래는 프로그래머스 추천을 가장 많이 받은 정답이다.

```jsx
function solution(lottos, win_nums) {
    const rank = [6, 6, 5, 4, 3, 2, 1];

    let minCount = lottos.filter(v => win_nums.includes(v)).length;
    let zeroCount = lottos.filter(v => !v).length;

    const maxCount = minCount + zeroCount;

    return [rank[maxCount], rank[minCount]];
}
```

일단 여기서 내가 배워야할 점을 정리해보자.

1. !v
    
    0의 !는 true임을 활용한 코드이다.
    
    이게 되는지 나는 몰랐다. (JavaScript는 알면 알수록 신기한 녀석이다)
    
2. rank 배열
    
    나는 마지막 result에서 삼항 연산자를 활용했지만 이게 더 깔끔하고 이해하기 쉬운 코드인것 같다.
    

확실히 내 코드보다 훨씬 깔끔하고 이해하기도 쉽다.

> 아직 이해 안가는건 왜 let을 썼는지는 모르겠다.
>