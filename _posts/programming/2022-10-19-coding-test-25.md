---
layout: post
title: "[Algorithm] - 25. 프로그래머스 - [스택/큐] 다리를 지나는 트럭"
subtitle:   "algorithm - 25. programmers "
categories: algorithm
tags: algorithm
comments: true
---


[코딩테스트 연습 - 다리를 지나는 트럭](https://school.programmers.co.kr/learn/courses/30/lessons/42583)

### 나의 풀이

---

```jsx
function solution(bridge_length, weight, truck_weights) {
  const bridge = new Array(bridge_length).fill(0);
  let bridgeWeight = 0;
  let count = 0;
    
    do {
    count++;
    //트럭 하나 하차
    const leaveTruckWeight = bridge.shift();
    bridgeWeight -= leaveTruckWeight;
    //bridge 다리의 현재 무게 + 다음 트럭의 무게 - 이제 나갈 트럭의 무게 
    if(bridgeWeight + truck_weights[0] <= weight) {
      //다음 트럭 진입
        const entryTruck = truck_weights.shift();
        bridge.push(entryTruck);
        bridgeWeight += entryTruck;
    }else {
      //트럭 진입 실패 대신 무게 0 진입
      bridge.push(0);
    }

      //다리의 무게가 0이 될때 까지 
    }while(bridgeWeight!==0);
 
    
    return count;
}
```

나의 풀이는 

1. 이동 횟수를 1 증가 시킨다.
2. bridge에서 트럭하나를 뺴고 해당 무게를 전체 무게에서 뺀다.
3. bridgeWeight에 다음 진입해야하는 트럭의 무게를 더해서 한계무게(weight)보다 작거나 같은지 확인한다.
    1. 같거나 작으면 진입 가능하니 진입가능한 트럭(truck_weights)에서 하나 빼고 bridge에 넣는다. 그리고 bridgeWeight에도 무게를 추가한다.
    2. 크다면 진입이 불가능하다는 의미로 bridge에 0을 넣는다 (단순 전진의 의미)
4. 위 과정을 다리의 무게가 0이 될때까지 반복한다.

여기서 다른분들의 풀이중에 배울만한 풀이는

```jsx
function solution(bridge_length, weight, truck_weights) {
  // '다리'를 모방한 큐에 간단한 배열로 정리 : [트럭무게, 얘가 나갈 시간].
  let time = 0, qu = [[0, 0]], weightOnBridge = 0;

  // 대기 트럭, 다리를 건너는 트럭이 모두 0일 때 까지 다음 루프 반복
  while (qu.length > 0 || truck_weights.length > 0) {
    // 1. 현재 시간이, 큐 맨 앞의 차의 '나갈 시간'과 같다면 내보내주고,
    //    다리 위 트럭 무게 합에서 빼준다.
    if (qu[0][1] === time) weightOnBridge -= qu.shift()[0];

    if (weightOnBridge + truck_weights[0] <= weight) {
      // 2. 다리 위 트럭 무게 합 + 대기중인 트럭의 첫 무게가 감당 무게 이하면 
      //    다리 위 트럭 무게 업데이트, 큐 뒤에 [트럭무게, 이 트럭이 나갈 시간] 추가.
      weightOnBridge += truck_weights[0];
      qu.push([truck_weights.shift(), time + bridge_length]);
    } else {
      // 3. 다음 트럭이 못올라오는 상황이면 얼른 큐의
      //    첫번째 트럭이 빠지도록 그 시간으로 점프한다.
      //    참고: if 밖에서 1 더하기 때문에 -1 해줌
      if (qu[0]) time = qu[0][1] - 1;
    }
    // 시간 업데이트 해준다.
    time++;
  }
  return time;
}
```

시간을 계산하는 부분에서 내 풀이는 따로 시간을 계산하지 않고 반복 할때마다 1초가 간다고 가정했다.

그리고 전체 bridge에 이동이 없으면 0을 넣으면서 한칸씩 전진시키면서 전체 시간을 계산했는데

위 풀이는 각 트럭별로 자신의 시간을 기록하고

반복문 마다 해당 시간을 체크해서 전체 무게에서 빼주도록 되어있다.

그리고 만약 다음 트럭이 못올라온다면 트럭 1대가 빠질떄까지 결국 대기해야함으로

시간을 점프하도록 설계가 되어있었다.

이 부분이 내 코드와의 시간차이를 발생시킨것 같다.