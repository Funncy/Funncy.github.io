---
layout: post
title: "[Algorithm] - 1. 프로그래머스 - 신고 결과 받기 "
subtitle:   "algorithm - 1. programmers "
categories: algorithm
tags: algorithm
comments: true
---

[코딩테스트 연습 - 신고 결과 받기](https://school.programmers.co.kr/learn/courses/30/lessons/92334)

결과 : 성공

내 코드:

```jsx
function solution(id_list, report, k) {
  //id_list에서 들어온 데이터를 Map 데이터로 만든다. => 신고된 횟수와 신고한 사람 데이터배열을 저장할 공간을 만든다.
  // report에서 들어온 데이터를 순회하면서 신고자와 신고당한 사람을 나눈다. => 신고당한 사람을 위 데이터에서 조회하여 신고자가 없으면 숫자 + , 있으면 무시

  //마지막에 k값보다 신고값이 높은 유저를 찾는다 => 찾은 유저의 신고자를 확인하고 새로운 데이터 타입에 카운트를 증가 시킨다 (메일 받은 사람)
  //즉, id_list로 2가지 데이터를 만들자

  const users = id_list.reduce((newObject, obj) => {
    newObject[obj] = {
      reportCount : 0,
      reporter : [],
      mailCount : 0,
    }
    return newObject;
  },  {});

  report.forEach((e)=> {
    const reportData = e.split(' ');
    const reporter = reportData[0];
    const reported =  reportData[1];

    //첫 신고
    if(users[reported].reporter.find((e) => e === reporter) === undefined) {
      users[reported].reportCount++;
      users[reported].reporter.push(reporter);
    }
  });

 Object.keys(users).forEach((key)=> {
    if(users[key].reportCount >= k) {
      users[key].reporter.forEach((reporter)=>{
        users[reporter].mailCount++;
      });
    }
  })

  const result = Object.keys(users).map((key)=>{
      return users[key].mailCount;
  })

  return result;
  
}
```

가장 칭찬 받은 코드 :

```jsx

function solution(id_list, report, k) {
    let reports = [...new Set(report)].map(a=>{return a.split(' ')});
    let counts = new Map();
    for (const bad of reports){
        counts.set(bad[1],counts.get(bad[1])+1||1)
    }
    let good = new Map();
    for(const report of reports){
        if(counts.get(report[1])>=k){
            good.set(report[0],good.get(report[0])+1||1)
        }
    }
    let answer = id_list.map(a=>good.get(a)||0)
    return answer;
}
```

### 피드백

---

아직 내가 js의 **Array문법**이 어색해서 찾아보면서 하느라 시간이 오래 걸렸다.

어려운 문제가 아니였지만 내가 생각했던 구조보다 칭찬 받은 코드가 더 깔끔해보인다.

물론 변수를 하나씩 지정해주면 더 좋아보이긴 한다.

**Set, Map**을 활용한 이 문제를 잘 기억해서 다음 문제에서 활용해보자.

> 다음 문제 풀기전에 이걸 다시 한번 봐보고 들어가자
>