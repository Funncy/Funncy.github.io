---
layout: post
title: "[Algorithm] - 20. 프로그래머스 - [DFS/BFS] 타켓넘버"
subtitle:   "algorithm - 20. programmers "
categories: algorithm
tags: algorithm
comments: true
---


[코딩테스트 연습 - 타겟 넘버](https://school.programmers.co.kr/learn/courses/30/lessons/43165)

### 나의 풀이

---

```jsx
function solution(numbers, target) {
  return dfs(0, 0, target, numbers);
}

function dfs(level, sum, target, numbers) {
  if (level === numbers.length) {
    if (sum === target) {
      return 1;
    }
    return 0;
  }

  const left = dfs(level + 1, sum + numbers[level], target, numbers);
  const right = dfs(level + 1, sum - numbers[level], target, numbers);
  return left + right;
}
```

이건 딱 보자마자 dfs로 푸는 문제구나 싶었다.

사실상 완전탐색이지만 트리구조로 +,-를 뻗어나가서 전체 배열 갯수와 같아졌을때 dfs로 합이 같은거만 찾으면 되는 문제였다.

다른 분들 풀이중에 인상깊었던 것은

```jsx
function solution(numbers, target) {
    let answer = 0;
    getAnswer(0,0);
    function getAnswer(x,value) {
        if(x<numbers.length){
            getAnswer(x+1,value + numbers[x]);
            getAnswer(x+1,value - numbers[x]);
        } else{
            if(value === target){
                answer++
            }
        }
    }
    return answer;
}
```

위 코드는 함수를 함수 내부에 선언해서 내 코드에서 numbers, sum과 같은 부분을 없앨 수 있었다.

```jsx
function solution(numbers, target) {
    var answer = 0;
    var answer = 0;

    let root = new BinarySearchTree();
    root.insert(0);
    numbers.forEach(function(val) {
       root.insert(val); 
    });

    answer = root.DFSPreOrder(target);
    return answer;
}

class Node {
    constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
    }   
}
class BinarySearchTree {
    constructor() {
        this.root = null;
    }
    insert(value) {
        let newNode = new Node(value);
        if(this.root === null) {
            this.root = newNode;
            return this;
        } else {
            let current = this.root;
            function traverse(node) {
                if(node.left) traverse(node.left);
                if(node.right) traverse(node.right);
                if(node.left === null) {
                    let leftNode = new Node(-value);
                    let rightNode = new Node(value);
                    node.left = leftNode;
                    node.right = rightNode;
                }
            }
            traverse(current);
            return this;
        }
    }
    DFSPreOrder(target) {
        let count = 0;
        let data = 0;
        let current = this.root;
        function traverse(node) {
            data = data + node.value;
            if(node.left) traverse(node.left);
            if(node.right) traverse(node.right);
            if(node.left === null) {
                if(data === target) {
                    count++;
                }
            }
            data = data - node.value;
        }
        traverse(current);
        return count;
    }
}
```

위 정답은 정말 정석으로 DFS를 구현해서 작성한 코드인데 참고하기 좋아보여서 가져왔다.

아마 회사는 위와 같은 코드를 좋아할 것 같다.