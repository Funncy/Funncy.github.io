---
layout: post
title: "[Algorithm] - 10. 프로그래머스 - [해쉬] 위장"
subtitle:   "algorithm - 10. programmers "
categories: algorithm
tags: algorithm
comments: true
---




[코딩테스트 연습 - 위장](https://school.programmers.co.kr/learn/courses/30/lessons/42578)

### 나의 코드

---

```jsx
function solution(clothes) {
  if(clothes.length === 0 ) return 0;
  const clothesMap = new Map();

  clothes.forEach((e)=>{
    if(clothesMap.get(e[1]) === undefined ) {
      clothesMap.set(e[1],  [e[0]]);
    }else {
       clothesMap.get(e[1]).push(e[0]);
    }
});

let result = 1;
  for(let item of clothesMap.values()) {
    result *= (item.length + 1); 
  }
  return result-1;
}
```

처음에는 경우의 수 계산을 어떻게 할지 혼란스러웠는데

전체의 경우에서 아무것도 안입은 경우를 빼는 방식으로 해결하였다.

### 다른 분들의 풀이

---

```jsx
function solution(clothes) {
    let answer = 1;
    const obj = {};
    for(let arr of clothes) {
        obj[arr[1]] = (obj[arr[1]] || 0) + 1;
    }

    for(let key in obj) {
        answer *= (obj[key]+1);
    }

    return answer - 1;
}
```

여기서 나와 차이점은 나는 옷의 이름을 배열로 저장하여서 length로 계산하였는데

다른분들을 보니 그냥 처음부터 숫자로 갯수를 저장하였다.

> 여기서 object[arr[1]] || 0 을 보면서 이렇게도 가능하구나 싶었다.
나는 정직하게 if문으로 undefined를 물어보았다.
> 

이거보다 더 간결한 코드는

```jsx
function solution(clothes) {
    return Object.values(clothes.reduce((obj, t)=> {
        obj[t[1]] = obj[t[1]] ? obj[t[1]] + 1 : 1;
        return obj;
    } , {})).reduce((a,b)=> a*(b+1), 1)-1;    
}
```

사실 해석해보면 위 코드랑 똑같은 코드이다. 

하지만 나는 이게 더 가독성이 떨어져서 위 코드가 좋다고 생각한다.