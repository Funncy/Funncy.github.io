---
layout: post
title: "[Algorithm] - 7. 프로그래머스 - 키패드 누르기 "
subtitle:   "algorithm - 7. programmers "
categories: algorithm
tags: algorithm
comments: true
---



[코딩테스트 연습 - 키패드 누르기](https://school.programmers.co.kr/learn/courses/30/lessons/67256)

### 내 코드

---

```jsx
function solution(numbers, hand) {

  // #, * 은 -1로 간주
  let cLeft = -1;
  let cRight = -1;

  //2,5,8,0은 왼손 오른손 양손 다 사용 가능한 영역
  //거리별 배열
  const conflictArea = {
    2: {
      1: [1, 3, 5],
      2: [4, 8, 6],
      3: [7, 9, 0],
      4: [-1],
    },
    5: {
      1: [2, 4, 6, 8],
      2: [1, 3, 7, 9, 0],
      3: [-1],
    },
    8: {
      1: [5, 7, 9, 0],
      2: [2, 4, 6, -1],
      3: [1, 3],
    },
    0: {
      1: [8, -1],
      2: [5, 7, 9],
      3: [2, 4, 6],
      4: [1, 3],
    }
  };

  const conflictArea2 = {
    2: [
      //1, 2 , 3
      1, 0, 1,
      //4,5,6
      2, 1, 2,
      //7,8,9
      3, 2, 3,
      //*0#
      4, 3, 4
    ],
    5: [
      //1, 2 , 3
      2, 1, 2,
      //4,5,6
      1, 0, 1,
      //7,8,9
      2, 1, 2,
      //*0#
      3, 2, 3
    ],
    8: [
      //1, 2 , 3
      3, 2, 3,
      //4,5,6
      2, 1, 2,
      //7,8,9
      1, 0, 1,
      //*0#
      2, 1, 2,
    ],
    0: [
      //1, 2 , 3
      4, 3, 4,
      //4,5,6
      3, 2, 3,
      //7,8,9
      2, 1, 2,
      //*0#
      1, 0, 1,
    ],
  };

  const leftArea = [1, 4, 7];
  const rightArea = [3, 6, 9];

  return numbers.map((currentNum) => {
 
    //현재 번호가 왼손 영역일 때
    if (leftArea.findIndex((e) => e === currentNum) !== -1) {
      cLeft = currentNum; //현재 왼손의 위치 변경
      return 'L';
    }
    //현재 번호가 오른손 영역일 때
    if (rightArea.findIndex((e) => e === currentNum) !== -1) {
      cRight = currentNum;
      return 'R';
    }

    let leftPosition = cLeft === -1 ? 9  : cLeft === 0 ? 10 : cLeft - 1;
    let rightPosition = cRight === -1 ? 11  : cRight === 0 ? 10 : cRight - 1;
    const leftDistance = conflictArea2[currentNum][leftPosition];
    const rightDistance = conflictArea2[currentNum][rightPosition];

    if(leftDistance < rightDistance) {
      cLeft = currentNum;
      return 'L';
    } else if(leftDistance > rightDistance) {
      cRight = currentNum;
      return 'R';
    }else if(hand === 'right') {
      cRight = currentNum;
      return 'R';
    }else {
      cLeft = currentNum;
      return 'L';
    }

  }).join('');
}
```

나는 각 번호별 다른 번호의 이동거리를 데이터로 만들어

내 손가락별 현재 위치에 따른 이동 거리를 계산하여 풀려고했다.

다른 분들의 풀이를 보면서 더 간단한 방법이 있음을 알았다.

### 다른 분들의 풀이

---

```jsx
function solution(numbers, hand) {
  hand = hand[0] === "r" ? "R" : "L"
  let position = [1, 4, 4, 4, 3, 3, 3, 2, 2, 2]
  let h = { L: [1, 1], R: [1, 1] }
  return numbers.map(x => {
    if (/[147]/.test(x)) {
      h.L = [position[x], 1]
      return "L"
    }
    if (/[369]/.test(x)) {
      h.R = [position[x], 1]
      return "R"
    }
    let distL = Math.abs(position[x] - h.L[0]) + h.L[1]
    let distR = Math.abs(position[x] - h.R[0]) + h.R[1]
    if (distL === distR) {
      h[hand] = [position[x], 0]
      return hand
    }
    if (distL < distR) {
      h.L = [position[x], 0]
      return "L"
    }
    h.R = [position[x], 0]
    return "R"
  }).join("")
}
```

내가 한 것처럼 번호별 거르를 배열로 만든게 아니라

초기 거리를 자료구조로 만들어놓고

연산을 통해서 거리를 구했다.

대각선으로 이동을 못한다는 특징을 고려해서

X축 연산 Y 축 연산을 분리해서 계산하였다.

위처럼 position에서 

123 가장 위이므로 4번

456 은 그다음로 3번

789는 그 다음으로 2번

0은 가장 마지막 1번이다.

h는 현재 손의 위치로 1번값은 Y축의 현재 라인 번호이다.

position에서 1,2,3,4로 이동거리를 잡은것을 기준으로 했고

2번값은 X축으로 * , #에 있으면 2,5,8,0을 누르려면 이동해야하니 1을 기본값으로 두었다.