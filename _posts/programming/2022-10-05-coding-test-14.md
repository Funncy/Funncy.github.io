---
layout: post
title: "[Algorithm] - 14. 프로그래머스 - [힙] 디스크 컨트롤러"
subtitle:   "algorithm - 14. programmers "
categories: algorithm
tags: algorithm
comments: true
---



[코딩테스트 연습 - 디스크 컨트롤러](https://school.programmers.co.kr/learn/courses/30/lessons/42627)

### 나의 풀이

---

```jsx
function solution(jobs) {
    let avgSum = 0;
    let current = 0;
  const length = jobs.length;
  let currentJob;
	//시작 가능한 시간을 기준으로 정렬
  jobs.sort((a,b) => {
      if(a[0] === b[0]) return a[1] - b[1];
      return a[0] - b[0];
    });

//잡큐가 남아있을떄가지 작업
  while(jobs.length > 0) {
    
//바로 시작이 가능한 job들을 찾아서 소요시간으로 정렬 
    const orderedJob = jobs.filter((e)=>e[0] <= current).sort((a,b) => a[1] - b[1]);
  if(orderedJob.length > 0) {
    currentJob = orderedJob[0];
      
    }else {
//바로 시작이 가능한 작업이 없을경우 첫번째 작업 선택
    currentJob = jobs[0];
    current = currentJob[0];
    }

//소요 시간 및 평균 소요 시간 계산
    current += currentJob[1];
    avgSum += (current - currentJob[0]);

//작업이 끝난 큐 삭제
  const idx = jobs.findIndex((e)=> e[0] === currentJob[0] && e[1] === currentJob[1]);
    if(idx > -1 ) jobs.splice(idx,1);
  }
  
  return Math.floor(avgSum / length);
}
```

처음에 Math.floor를 안해줘서 다 오류가 떠서 당황했다… 다음부터는 문제부터 정확히 읽자…

다른 사람 풀이를 보며 내 풀이의 개선점을 고민해보았다.

### 다른 분들 풀이

---

```jsx
function solution(jobArr) {
    var answer = 0;
    jobArr = jobArr.sort((a, b) => a[0] - b[0]);
    let queue = [];
    let time = 0;
    let i = 0;
    while(queue.length > 0 || i < jobArr.length) {
        if(jobArr.length > i && jobArr[i][0] <= time) {
            queue.push(jobArr[i++]);
            queue.sort((a, b) => a[1] - b[1]);
            continue;
        }
        if(queue.length > 0) {
            let [ start, work ] = queue.shift();
            answer = answer + time - start + work;
            time += work;
        } else if(queue.length == 0) {
            time = jobArr[i][0];
        }
    }

    return parseInt(answer / jobArr.length);
}
```

위 풀이에서 배울점은

1. 예외처리 대응
    
    위 문제의 예외 케이스중 하나가 바로 시작이 불가능한 경우이다.
    
    그때 내 코드에서는 예외처리로 시작값을 바꾸고 첫번째 작업을 가져오기 하는데
    
    위 코드에서는 반복문 내에서 자연스럽게 처리한다.
    
    반복문 내에서 queue를 추가하지 못해도 아래에서 추가하지 못한 경우에 `time = jobArr[i][0];` 으로 자연스럽게 시작 시간을 당겨준다.
    
2. queue 정렬
    
    내 코드에서는 orderedJobs 이라고 filter를 써서 꺼내온거에서 sort로 정렬을 진행했다.
    
    위 코드는 해당 영역에서만 push를 하고 정렬을 한다.
    
    > 하나 개선하고 싶은 점은 sort를 매번 하기 보다 아래 qeue.length>0 인 부분에서만 실행해도 좋을것 같다.
    > 
    

```jsx
function solution(jobs) {
    jobs.sort(([a, b], [c, d]) => a - c || b - d);
    const waiting = [];
    const count = jobs.length;
    let processed_time = 0;
    let time = 0;
    while (jobs.length + waiting.length) {
        let in_process;
        while (jobs.length && (jobs[0][0] <= time)) {
            waiting.push(jobs[0] && jobs.shift());
        }
        if (waiting.length) {
            in_process = waiting.sort(([a, b], [c, d]) => b - d || a - c).shift();
        } else {
            in_process = jobs.shift();
            time = in_process[0];
        }
        time += in_process[1];
        processed_time += time - in_process[0];
    }
    return Math.floor(processed_time / count);
}
```

이 코드가 내 로직 흐름과 유사하면서 깔끔하게 정리한 코드인것 같다.

내 코드에서 jobs를 작업이 끝나면 하나씩 삭제하고 있는데 위처럼 shift를 사용하면 자연스럽게 삭제되니 더 좋은것 같다.