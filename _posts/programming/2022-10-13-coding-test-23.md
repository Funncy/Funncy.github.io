---
layout: post
title: "[Algorithm] - 23. 프로그래머스 - [그래프] 가장 먼 노드"
subtitle:   "algorithm - 23. programmers "
categories: algorithm
tags: algorithm
comments: true
---

[코딩테스트 연습 - 가장 먼 노드](https://school.programmers.co.kr/learn/courses/30/lessons/49189)

### 나의 풀이

---

```jsx
function solution(n, edge) {
  const graph = new Array(n).fill().map((_) => []);
  for (let item of edge) {
    graph[item[0] - 1].push(item[1] - 1);
    graph[item[1] - 1].push(item[0] - 1);
  }

  const visited = [1];
  const queue = [0];

  while (queue.length > 0) {
    const curIndex = queue.shift();

    for (const vertex of graph[curIndex]) {
      if (visited[vertex] === undefined) {
        visited[vertex] = visited[curIndex] + 1;
        queue.push(vertex);
      }
    }
  }

  return visited.filter((e) => e === Math.max(...visited)).length;
}
```

BFS로 접근해서 가장 높은 depth의 숫자를 반환해주면 되는 문제이다.

여기서 처음에 실수했던 포인트는 depth 계산을 해줄때 while안에서 직접해주려고 했었다.

queue에서 shift 한다고 depth가 늘어나는게 아님을 다시 명심하자