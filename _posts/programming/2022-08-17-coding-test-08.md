---
layout: post
title: "[Algorithm] - 8. 프로그래머스 - 같은 숫자는 싫어 "
subtitle:   "algorithm - 8. programmers "
categories: algorithm
tags: algorithm
comments: true
---


[코딩테스트 연습 - 같은 숫자는 싫어](https://school.programmers.co.kr/learn/courses/30/lessons/12906)

### 나의 풀이

---

```jsx
function solution(arr) {

  let temp;
  let currentVal;
  var answer = [];

  arr.forEach((e) => {
    temp = e;
    if (temp !== currentVal) {
      currentVal = temp;
      answer.push(currentVal);
    }
  });

  if (currentVal !== arr[arr.length - 1]) {
    answer.push(temp);
  }

  return answer;
}
```

처음에는 위 같이 풀었따.

반복문을 돌면서 현재값과 이전값이 다른 부분을 찾아서 해당 부분을 더해주고,

반복이 다 끝나고 배열의 마지막 값이 현재 값과 다르다면 추가해주었다.

그리고 개선을 해보려고 아래와 같이 변경하였다.

```jsx
function solution(arr) {

  var answer = [];
  if (arr.length == 1) return arr;

  arr.reduce((prev, current, index) => {
    if (prev !== current) {
      answer.push(prev);
    }

    if (index === arr.length - 1) {
      answer.push(current);
    }

    return current;
  });

  return answer;
}
```

reduce를 통해 이전값과 현재값 그리고 인덱스 값을 받아서

이전값과 현재값이 같지 않으면 추가하게 해주었고

똑같이 배열의 마지막 값은 추가해주었다.

> 예외 케이스로 Reduce는 자료가 1개일때 돌아가지 않는다.
즉 배열 길이가 1인 경우는 오류가 발생하여서 위에 예외 반환문을 추가해주었다.
> 

> 성능 차이도 발생하였다.
reduce로 짠 코드가 효율성 테스트에서도 2배 가까이 좋은 성능을 받았다.
1번 코드 : 약 45ms
2번 코드 : 약 25ms
> 

### 다른 분들의 풀이

---

```jsx
function solution(arr)
{
    return arr.filter((val,index) => val != arr[index+1]);
}
```

위 코드가 가장 심플하고 좋았다.

filter를 사용해서 현재값과 다음값이 다른것만 반환하라고 짜여져있다.

내가 여기서 배운것은 filter도 filter지만

나와의 접근 차이였다.

나는 이전값 - 현재값으로 접근해서 

결국 마지막에 조건문으로 배열의 마지막 원소면 추가해라 라는 코드가 들어갈 수 밖에 없는 구조였다.

하지만 JS를 잘 쓰는 사람들은 arr[index+1]을 활용하여 코드를 더욱 깔끔하게 짤 수 있었다.

> 다른언어는 index범위가 안맞으면 exception이 발생하지만 
js는 undefined를 반환한다.
다른언어는 index+1이라는 미친짓은 보통하지 못한다…
>