---
layout: post
title: "[Algorithm] - 4. 프로그래머스 - 문자열 압축 "
subtitle:   "algorithm - 4. programmers "
categories: algorithm
tags: algorithm
comments: true
---

[https://school.programmers.co.kr/learn/courses/30/lessons/60057](https://school.programmers.co.kr/learn/courses/30/lessons/60057)

이번에 푼 문제는 레벨2 문제였다.

처음 풀이와 그 다음 풀이로 개선해보았다.

처음에는 두통도 있었어서 console.log로 디버깅 하며 일단 풀리는대로 만들어보았다.

```jsx
function solution(s) {
  //먼저 글자 길이 만큼 반복하면서 1~length까지 진행
  // 1글자씩 쪼개서 볼때 케이스 데이터 체크 
  // 2글자씩 쪼개서 볼떄 케이스 데이터 체크
  const data = s.split('');
  let min = 999;

  for (let i = 0; i < data.length / 2; i++) {
    let count = 0;
    let group = [];
    let reduceIndex = -1;
    const groupData = data.reduce((e, element) => {
      reduceIndex++;
      group.push(element);
      if (group.length == i + 1) {
        e.push(group);
        group = [];
        return e;
      }

      if (reduceIndex == data.length - 1) {

        e.push(group);
      }
      return e;
    }, []);

    let currentCharacter = data.slice(0, i + 1);
    let currentChar = currentCharacter.join('');

    const cal = [];
    let calResult = 0;
    groupData.forEach((e, index) => {
      const mergeElement = e.join('');

      if (currentChar !== mergeElement) {
        calResult += count > 1 ? count < 10 ? currentChar.length + 1 : 2 + currentChar.length : currentChar.length;
        cal.push(count > 1 ? count < 10 ? currentChar.length + 1 : 2 + currentChar.length : currentChar.length);
        count = 1;

        if (index == groupData.length - 1) {
          calResult += count > 1 ? count < 10 ? mergeElement.length + 1 : 2 + mergeElement.length : mergeElement.length;
          return cal.push(count > 1 ? count < 10 ? mergeElement.length + 1 : 2 + mergeElement.length : mergeElement.length);
        }

        currentChar = mergeElement;
        return;

      }

      count++;

      if (index == groupData.length - 1) {
        calResult += count > 1 ? count < 10 ? currentChar.length + 1 : 2 + currentChar.length : currentChar.length;
        return cal.push(count > 1 ? count < 10 ? currentChar.length + 1 : 2 + currentChar.length : currentChar.length);
      }

    });

    if (min > calResult) {
      min = calResult;
    }

  }

  return min;

}
```

문자열에서 1글자, 2글자…씩 배열을 만들어서 비교를 해야해서

처음에는 reduce로 groupData라고 배열을 만들어서 구현해봤다.

다 만들고 보니 slice로 활용하는게 더 좋아보여서 개선하게 되었다.

```jsx
function solution(s) {
  //글자길이의 절반만큼 반복 
  //한 조각의 길이는 i+1 
  let min = 9999;
  for (let i = 0; i < s.length / 2; i++) {
    //currnetStr 에 sice를 활용해서 (0, i+1)의 글자 저장
    let currentStr = s.slice(0, i + 1);

    //
    let count = 1;
    let result = '';
    for (let j = i + 1 ; j < s.length; j += i + 1) {
      let str2 = s.slice(j, j + i + 1);

      if (currentStr != str2) {
        result += count > 1 ? count.toString() + currentStr : currentStr;
        currentStr = str2;
        count = 1;
      } else {
        count++;
      }
    }
    result += count > 1 ? count.toString() + currentStr : currentStr;

    if(min >= result.length) min = result.length;

  }
  return min;
}
```

조금 더 코드가 깔끔해졌다.

다른 분들의 풀이를 비교해보자.

```jsx
const solution = s => {
  const range = [...Array(s.length)].map((_, i) => i + 1);
  return Math.min(...range.map(i => compress(s, i).length));
};

const compress = (s, n) => {
  const make = ([a, l, c]) => `${a}${c > 1 ? c : ''}${l}`;
  return make(
    chunk(s, n).reduce(
      ([a, l, c], e) => e === l ? [a, l, c + 1] : [make([a, l, c]), e, 1],
      ['', '', 0]
    )
  );
};

const chunk = (s, n) =>
  s.length <= n ? [s] : [s.slice(0, n), ...chunk(s.slice(n), n)];
```

가장 자바스크립트 답게 푼 정답 같았다.

재귀와 함수형을 활용해서 푼 정답이다.

그다음은 인상깊었던 풀이다.

```jsx
function solution (s) {
    const minGroupCount = 1
    const maxGroupCount = Math.floor(Math.ceil(s.length / 2))

    let resultArray = []

    for (let i=minGroupCount; i<=maxGroupCount; i++) {
        let slicedArray = []
        for (let j=0; j<s.length; j=j+i) {
            slicedArray.push(s.slice(j, j+i))
        }

        let resultStr = ''
        let cnt = 1
        for (let i=0; i<slicedArray.length; i++) {
            const current = slicedArray[i]
            const next = slicedArray[i+1]

            if (slicedArray[i] === slicedArray[i+1]) {
                cnt++
            }
            else {
                resultStr = resultStr + (cnt-1 ? cnt : '') + current
                cnt = 1
            }
        }
        resultArray.push(resultStr.length)
    }

    return Math.min(...resultArray)
    // return c
}
```

사실 별거 없어 보이지만 내가 처음 이 코드를 봤을때 가장 의아했던 부분은

slicedArray[i+1] 이 였다. 분명 다른 언어라면 exception이 떠야하는 부분이지만 javascript는 undefined를 내뱉는다… 

그래서 마지막 원소를 처리하는 부분을 저런식으로도 해결이 가능하다

```jsx
function solution(s) {
  let minLen = s.length; //현재 스트링 길이로 시작한다.

  // 압축하는 문자열 길이를 1개씩부터, s의 반 까지 시도한다.
  top: for (let n = 1; n <= s.length / 2; n++) {
    // 이번 트라이얼의 문자열 길이 초기화한다.
    let curLen = 0;
    for (let i = 0; i < s.length; i += n) {
      // 이번 트라이얼의 길이 n 만큼 테스트를하고, 일치하는 수만큼 카운터로 계산
      // 불일치 시에 다음으로 진행
      let counter = 1;
      while (s.slice(i, i + n) === s.slice(i + n, i + 2 * n)) {
        i += n;
        counter++;
      }
      // 만약 하나도 일치가 없었으면, 테스트했던 문자열의 길이만큼만 더해주고,
      // 일치한 문자열이 하나라도 존재했다면 카운터를 스트링으로 변환 후 길이를 더해줌.
      if (counter !== 1) {
        curLen += n + (counter + "").length;
      } else {
        // 1일경우 그냥 n을 더해주는데, 혹시 맨 마지막에 남은 문자열이 n이하일 경우
        // 남는 수만 더해준다.
        curLen += s.length < i + n ? s.slice(i, i + n).length : n;
      }
      // 현재까지의 최소길이보다 현재길이가 커지는 순간, 다음 트라이얼 시작.
      if (minLen <= curLen) continue top;
    }
    // 여기까지 살아남았으면 이번 길이가 최소길이다.
    minLen = curLen;
  }
  return minLen;
}
```

위 코드도 인상 깊었다.

while 문을 활용해서 현재 조각이 같은 부분까지 쭉 진행한 카운트로 바로 계산하고

또 continue 문을 활용해 쓸모없는 연산을 줄여버렸다.

2단계를 풀면서 정말 더 열심히 공부해야겠다고 생각했다.

다음 문제도 열심히 풀어보자