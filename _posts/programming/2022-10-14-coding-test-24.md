---
layout: post
title: "[Algorithm] - 24. 프로그래머스 - [이분탐색] 징검다리"
subtitle:   "algorithm - 24. programmers "
categories: algorithm
tags: algorithm
comments: true
---



[코딩테스트 연습 - 징검다리](https://school.programmers.co.kr/learn/courses/30/lessons/43236)

위 문제는 이분 탐색이라는 흰트가 없었다면 이분탐색으로 접근하기 어려웠을 것 같다.

아직 알고리즘 분류 능력을 더 키워야겠다는 생각이 들었다.

일단 이분탐색을 어느 기준으로 돌면 좋을까에서 

가장 범위가 큰 distance를 기준으로 돌면 좋겠다고 생각까지는 했지만

rocks를 어떻게 n개 만큼 빼면서 진행할까 부분에서 막혀서 다른 분 들의 접근을 찾아보았다.

```jsx
function solution(distance, rocks, n) {
  let answer = 0;
  let max = distance;
  let min = 0;

  rocks.sort((a, b) => a - b);

  while (min <= max) {
    const mid = Math.floor((max + min) / 2);

    let prevRock = 0;
    let removeRockCount = 0;
    for (let rock of rocks) {
      if (rock - prevRock <= (mid-1)) {
        removeRockCount++;
      } else {
        prevRock = rock;
      }
    }

    if (removeRockCount > n) {
      max = mid - 1;
    } else {
      min = mid + 1;
      answer = Math.max(mid, answer);
    }
  }

  return answer;
}
```

위 코드에서 가장 기본적인 이분 탐색 방식을 사용한다.

거의 포맷 같은거라 암기 해도 좋을것 같다.

```jsx
function solution(distance, rocks, n) {
  let answer = 0;
  let max = distance;
  let min = 0;

  rocks.sort((a, b) => a - b);

  while (min <= max) {
    const mid = Math.floor((max + min) / 2);

    if (...) {
      max = mid - 1;
    } else {
      min = mid + 1;
    }
  }

  return answer;
}
```

min , max 범위를 정해서 중간값 mid를 잡고 조건에 따라서 min , max를 mid를 기준으로 옮겨주면 된다.

min이 max보다 커지면 모든 탐색이 끝났다는 의미이다.

여기서 if 문 안에 어떤 내용이 들어가야 할까?

현재 문제에서 찾아야 하는 값은

n개 만큼 제거한 rocks의 가능한 경우중에서

각 바위의 간격 중 가장 작은값 중 최대값을 꺼내야 한다.

말이 어려운데 예시를 보면 쉽다….

| 제거한 바위의 위치 | 각 바위 사이의 거리 | 거리의 최솟값 |
| --- | --- | --- |
| [21, 17] | [2, 9, 3, 11] | 2 |
| [2, 21] | [11, 3, 3, 8] | 3 |
| [2, 11] | [14, 3, 4, 4] | 3 |
| [11, 21] | [2, 12, 3, 8] | 2 |
| [2, 14] | [11, 6, 4, 4] | 4 |

위 표에서는 4가 리턴되어야 한다.

그렇다면 if문 안에 어떤 내용이 들어가면 좋을까?

mid값은 우리가 찾아야하는 거리의 최솟값이다.

그렇다면 바위 사이의 거리 중 mid가 제일 작은 값이어야 한다.

만약 바위사이의 거리중 mid보다 작은 값이 있다면 그 바위가 바로 제거 대상이다!

```jsx
let prevRock = 0;
let removeRockCount = 0;
for (let rock of rocks) {
  if (rock - prevRock <= (mid-1)) {
    removeRockCount++;
  } else {
    prevRock = rock;
  }
}
```

그래서 매 이분탐색마다 mid보다 작거나 같은 값은 남은 배열에 존재해서는 안된다.

만약 크면 이제 그 돌을 기준으로 거리가 mid보다 작은 것을 찾아서 빼주면 된다.

```jsx
    if (removeRockCount > n) {
      max = mid - 1;
    } else {
      min = mid + 1;
      answer = Math.max(min, answer);
    }
```

그리고 마지막 이분탐색 분기 부분에서는

지워진 돌의 갯수가 n보다 크면 mid보다 작은 값으로 가능하다는 의미이다.

지워진 돌의 갯수가 n보다 작거나 같으면 mid보다 큰 값으로 가능하다는 의미이다.

여기서 우리는 가능한 값 중에 가장 큰 값을 찾고 있기때문에 answer는 작거나 같은 부분에서 진행해준다.

### 결론

---

문제에서 가능한 입력의 데이터가 큰 범위로 주어지면 이분탐색을 하라는 흰트로 받아들여야 할 것 같다.

그리고 어디를 기준으로 이분탐색을 해야하는지 찾아내는 연습을 더 해야할것 같다.