---
layout: post
title: "[Algorithm] - 13. 프로그래머스 - [해쉬] 베스트 앨범"
subtitle:   "algorithm - 13. programmers "
categories: algorithm
tags: algorithm
comments: true
---


[코딩테스트 연습 - 베스트앨범](https://school.programmers.co.kr/learn/courses/30/lessons/42579)

### 나의 풀이

---

```jsx
function solution(genres, plays) {
  const album = {}

  genres.forEach((value, index) => {
     if (album[value] === undefined) {
      album[value] = {
        total: plays[index],
        items: [{ index: index, count: plays[index] }],
      }
    } else {
      album[value].total += plays[index];
      const item = album[value].items;
      item.push({ index: index, count: plays[index] });
    }
  });

  
  return Object.entries(album).sort(([_,a], [__,b]) => b.total - a.total).map(([_, value])=> {
    const items = value.items;
    const orderedItems = items.sort((a,b) => b.count - a.count);
    return orderedItems.length > 1 ? [orderedItems[0].index, orderedItems[1].index] : [orderedItems[0].index];
  }).flatMap(x=>x);

  
}
```

나의 풀이에서 기본적인 로직의 흐름은

2개로 쪼개져서 들어온 장르와 재생수를 Object(map)으로 합치고

합쳐진 데이터에서 sort를 통해서 정리하고 map을 통해서 2개만 뽑아서 반환하는 구조로 작성하였다.

프로그래머스의 다른 풀이들과 나의 차이점은

나는 totalPlaycount까지 같은 Object에 넣었고,

다른 분들은 따로 관리해서 문제를 풀었다.

같이 넣을 경우에 Object가 더 복잡해지는 문제 + map이나 filter를 돌리기에 어려운 구조를 가진다는 문제를 확인하였다.

그중 한 풀이는 다른 흐름을 가지고 있었다.

```jsx
function solution(genres, plays) {
    var dic = {};
    genres.forEach((t,i)=> {
        dic[t] = dic[t] ?  dic[t] + plays[i] :plays[i];        
    });

    var dupDic = {};
    return genres          
          .map((t,i)=> ({genre : t, count:plays[i] , index:i}))
          .sort((a,b)=>{               
               if(a.genre !== b.genre) return dic[b.genre] - dic[a.genre];
               if(a.count !== b.count) return b.count - a.count;
               return a.index - b.index;
           })
           .filter(t=>  {
               if(dupDic[t.genre] >= 2) return false;
               dupDic[t.genre] = dupDic[t.genre] ? dupDic[t.genre]+ 1 : 1;
               return true;
            })
           .map(t=> t.index);    
}
```

일단 코드가 깔끔한것도 그렇고

내가 한것처럼 2개의 배열을 하나의 object로 합치는 과정 없이 genres에서 연산을 통해서 결과를 만들었다.

여기서 배울점은 sort에서 분기 처리를 통해 순서 정렬을 했다는 것이다.