---
layout: post
title: '[Flutter] - 교회 앱 만들기 - 1 '
subtitle: 'Flutter Church App 01'
categories: flutter
tags: flutter firebase firestore getx
comments: true
---

# 1. 폴더구조

---

![이미지](https://Funncy.github.io/assets/img/flutter/2021-04-02_church_app_00.png 'folder structure')

현재 나는 위와 같은 폴더구조를 생성하였다.

1. bindings ⇒ 의존성 주입을 위한 파일들이 모여있다.
2. components ⇒ 공통된 위젯을 관리하는 폴더이다.
3. core ⇒ Error, 스크린상태등 핵심 기능과 관련된 자료를 관리하는 폴더이다.
4. models ⇒ MVVM의 Model을 관리하는 폴더이다.
5. pages ⇒ Screen들이 모여있다. (Screen별로 각자 내부 폴더)
6. repositories ⇒ 서버와 통신하는 폴더이다.
7. services ⇒ Firebase등의 서비스등을 모아놓았다. (Firebase 관리)
8. utils ⇒ timeago등 시간, 다국어, parsing등 유틸에 관련된 폴더이다.
9. viewmodels ⇒ getX의 Controller들이 모여있다.

> 나중에 추가되면 업데이트 해보겠다.

현재 흐름은 pages ←Rx→ ViewModel ←→ Repository ←→Service(Firebase) 이다.

# 2. getX 간단한 사용

---

나는 getX에서 Router와 상태관리를 사용하려고한다.

1. Router

   ```java
   return GetMaterialApp(
         title: '두드리시오',
         theme: ThemeData(
           primarySwatch: Colors.blue,
           visualDensity: VisualDensity.adaptivePlatformDensity,
         ),
         initialRoute: '/',
         getPages: [
           GetPage(
               name: '/', page: () => NoticeScreen(), binding: NoticeBindings())
         ],
       );
   ```

   위와 같이 간단하게 설정이 가능하며 binding으로 GetController등을 주입해줄 수 있다. (의존성 주입)

2. 상태관리

   getX에서는 Rx변수를 제공해주며 변수가 변동되면 자동으로 화면이 rebuild된다. (obx를 까먹지는 말자)

   ```java
   //getController 부분
   class NoticeViewModel extends GetxController {
   	RxList<NoticeModel> notices = <NoticeModel>[].obs;
   	void addNotice(NoticeModel notice){
   		notices.add(notice);
   	}
   }

   //screen 부분
   Container(
   	child: Obx(()=> Text(noticeViewModel.notices[0].content))
   )
   ```

# 3. 공지사항 가져오기

---

이제 내가 구현한 공지사항 가져오기 코드의 설명이다.

먼저 모델을 만들자.

### NoticeModel

```java
class NoticeModel extends Core {
	String did;
  String uid;
  String content;
  List<String> images;
  int comments;
  int favorites;

  NoticeModel(
      {@required this.did,
			@required this.uid,
      @required this.content,
      @required this.images,
      @required this.comments,
      @required this.favorites});

  factory NoticeModel.fromFirestroe(DocumentSnapshot doc) {
    var json = doc.data();

    return NoticeModel(
				did: doc.id,
        uid: json['uid'],
        content: json['content'],
				images: json['images']?.cast<String>(),
				comments: json['comments'],
				favorites: json['favorites'],);
  }

  Map<String, dynamic> toJson() => {
				'did': did,
        'uid': uid,
        'content': content,
        'images': images,
				'comments': comments,
				'favorites': favorites,
      };
}
```

> fromJson이 아니라 fromFirestore로 구현하였다.
> 추후 fromJson도 추가해서 restAPI로 연동을 만들어보자.

### NoticeRepository

---

noticeRepository는 abstract class로 만들고 구현체는 따로 클래스 파일로 구성하였다.

```java
//notice_repository
abstract class NoticeRepository {
  Future<List<NoticeModel>> getNoticeList();
}
```

```java
class NoticeRepositoryImpl extends NoticeRepository {
  FirebaseFirestore _firebaseFirestore;

  NoticeRepositoryImpl({@required FirebaseFirestore firebaseFirestore}) {
    _firebaseFirestore = firebaseFirestore;
  }

  @override
  Future<List<NoticeModel>> getNoticeList() async {
    List<NoticeModel> notices = [];

    try {
      var noticeCollection =
          await _firebaseFirestore.collection('notice').get();
      for (var notice in noticeCollection.docs) {
        notices.add(NoticeModel.fromFirestroe(notice));
      }
    } catch (e) {
      throw ErrorModel(message: '파이어베이스 에러');
    }
    return notices;
  }

```

> 여기서 ErrorModel을 core폴더에 따로 만들어서 Exception을 처리해주는 용도로 사용하였다.

### NoticeViewModel

---

먼저 ViewModel을 만들기 전에 ViewModel에서 공통적으로 나오는 특징이 있었다.

- 화면 상태 저장 ⇒ initial, loading, loaded, empty, error
- 로직 호출 단계에서 화면 상태 변경

위 2개를 mixin으로 합쳐보려고 코드를 작성하였다.

```java
//screen_status.dart
enum Status { initial, loading, loaded, empty, error }

class ScreenStatus {
  Rx<Status> _status = Status.initial.obs;

  void setScreenStatus(Status status) {
    _status.value = status;
  }

  Status getScreenStatus() {
    return _status.value;
  }
}
```

```java
mixin GetDataWithScreen on ScreenStatus {
  Future<T> getDataWithScreenStatus<T>(Function getData) async {
    setScreenStatus(Status.loading);
    try {
      return await getData();
    } catch (e) {
      setScreenStatus(Status.error);
      return null;
    }
  }

  void checkEmptyWithScreenStatus<S>(List<S> result) {
    if (result.length == 0) {
      setScreenStatus(Status.empty);
    } else {
      setScreenStatus(Status.loaded);
    }
  }
}
```

> 위 mixin은 데이터를 가져오는 repository함수를 호출 할 때
> 각 단계별 화면 상태 변경 함수를 만들었다.

```java
class NoticeViewModel extends GetxController
    with ScreenStatus, GetDataWithScreen {
  NoticeRepository _noticeRepository;
  RxList<NoticeModel> notices = <NoticeModel>[].obs;

  NoticeViewModel({@required NoticeRepository noticeRepository}) {
    _noticeRepository = noticeRepository;
  }

  void getNoticeList() async {
		//데이터 호출 시작하면 Loading Widget
		//데이터 가져올때 Error면 Error Widget
    var result = await getDataWithScreenStatus(_noticeRepository.getNoticeList);

    if (result == null) {
      return;
    }

    notices.clear();
    notices.addAll(result);
		//데이터 비어있으면 Empty Widget
		//데이터가 비어있찌 않으면 Loaded Widget (실제 보여주고 싶은 화면)
    checkEmptyWithScreenStatus(result);
  }
}
```

위 2개 Class를 mixin하여 Viewmodel을 간단히 구현하였다.

### NoticeScreen

---

화면을 그리기전에 또 화면에서도 반복되는 패턴이 있었다.

- 화면 상태에 따라 분기해서 Widget 표시

현재 이걸 Switch문으로 작성했다가 다음 화면도 이게 반복될것이 보여서 바로 리팩토링을 진행하였다.

```java
class ScreenStatusWidget extends StatelessWidget {
  final Widget body;
  final Widget error;
  final Widget loading;
  final Widget empty;
  final Status screenStatus;

  const ScreenStatusWidget(
      {Key key,
      @required this.body,
      @required this.error,
      @required this.loading,
      @required this.empty,
      @required this.screenStatus})
      : super(key: key);

  @override
  Widget build(BuildContext context) {
    switch (screenStatus) {
      case Status.initial:
      case Status.loading:
        return loading;
        break;
      case Status.error:
        return error;
        break;
      case Status.empty:
        return empty;

        break;
      case Status.loaded:
        return body;
    }
    return error;
  }
}
```

이제 ScreenStatusWidget에 각자 알맞은 Widget을 넣어주면 알아서 분기가 된다.

이제 진짜 화면 코드를 봐보자.

```java
class NoticeScreen extends StatefulWidget {
  @override
  _NoticeScreenState createState() => _NoticeScreenState();
}

class _NoticeScreenState extends State<NoticeScreen> {
  final noticeViewmodel = Get.find<NoticeViewModel>();

  @override
  void initState() {
    noticeViewmodel.getNoticeList();
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text("공지사항"),
      ),
      body: Container(
        color: Colors.black12,
        child: Obx(() {
          var screenStatus = noticeViewmodel.getScreenStatus();
          var noticeList = noticeViewmodel.notices;
					//화면 상태 관리
          return ScreenStatusWidget(
              body: noticeListWidget(noticeList),
              error: ErrorMessageWidget(errorMessage: 'test'),
              loading: LoadingWidget(),
              empty: EmptyWidget(),
              screenStatus: screenStatus);
        }),
      ),
    );
  }

  Widget noticeListWidget(List<NoticeModel> noticeList) {
    return ListView.builder(
        itemCount: noticeList.length,
        itemBuilder: (context, index) {
          return noticeCard(noticeList[index]);
        });
  }
...
}
```

<img src="https://Funncy.github.io/assets/img/flutter/2021-04-02_church_app_01.png" height="700">

정상적으로 잘 동작한다.

### 다음과제

---

이제 화면을 더 세심하게 다듬고

- 이미지 분할 및 이미지 전용 슬라이더 제작
- Theme 설정
- 텍스트 스타일 및 아이콘 변경
- 좋아요 버튼 Toggle 동작
- 좋아요 누를 경우 아이콘 변경
- Detail화면 제작
- Detail화면에서 댓글 작성 기능
- 내가 작성한 댓글 삭제 및 수정 기능

...생각보다 많다

그리고 기능적으로는 나눔 게시판부터 만들어보자.
