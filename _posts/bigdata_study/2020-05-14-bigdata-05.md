---
layout: post
title: "[Bigdata] -  빅데이터 기초 05 : 빅데이터 저장에 대한 개념 "
subtitle:   "Bigdata - 빅데이터 기초"
categories: ml
tags: ml bigdata
comments: true
---

외부 소스에서 얻은 데이터의 비호환성을 해결하고 저장과 처리를 위해 `데이터 랭글링(data wrangling)`이 필요하다. 데이터 랭글링에는 다운스트림 분석을 위한 데이터 여과, 정제 및 준비 단계가 포함된다. 저장 장치의 관점에서 보면 처음에는 데이터의 복사본이 원본 형식으로 저장디고, 랭글링이 끝나면 처리된 데이터가 다시 저장되는 것이다.
일반적으로 다음과 같은 경우, 저장 장치가 필요하다.

+ 외부 데이터 세트를 수집해야 하거나 내부 데이터를 빅데이터 환경에서 사용해야 하는 경우
+ 데이터 분석을 위하여 데이터를 처리하는 경우
+ 데이터가 ETL 활동을 통해 처리되거나 분석 작업을 통해 결과물이 생성되는 경우

데이터 세트를 원본 또는 여러 복사본으로 저장해야 할 필요성 때문에 `저렴`하고 `확장성`이 높은 저장 솔루션을 구현하기 위한 혁신적인 전략과 기술이 개발되었다.

+ [1. 클러스터](#1-클러스터)
+ [2. 파일 시스템 및 분석 파일 시스템](#2-파일-시스템-및-분석-파일-시스템)
+ [3. NoSQL](#3-nosql)
+ [4. 샤딩](#4-샤딩)
+ [5. 복제](#5-복제)
    + [5-1) 마스터 슬레이브](#5-1-마스터-슬레이브)
    + [5-2) 피어 투 피어](#5-2-피어-투-피어)
+ [6. 샤딩 및 복제](#6-샤딩-및-복제)
    + [6-1) 샤딩 및 마스터 슬레이브 복제 결합](#6-1-샤딩-및-마스터-슬레이브-복제-결합)
    + [6-2) 샤딩 및 피어 투 피어 복제 결합](#6-2-샤딩-및-피어-투-피어-복제-결합)
+ [7. CAP 정리](#7-cap-정리)
+ [8. ACID](#8-acid)
+ [9. BASE](#9-base)
+ [10. ACID vs BASE](#10-acid-vs-base)

---

### 1. 클러스터 

클러스터(Clusters)는 밀접하게 결합된 `서버 또는 노드들의 모음`이다. 일반적으로 동일한 하드웨어 사양을 가진다. 클러스터를 통해 작업을 보다 세부적인 단위로 분할한 뒤, 해당 클러스터에 속한 다른 컴퓨터에 각 세부 작업을 할당하여 작업을 한꺼번에 수행할 수 있다.

---

### 2. 파일 시스템 및 분석 파일 시스템

파일 시스템은 저장 장치에 데이터를 저장하고 구성하는 방법이다. 파일은 파일 시스템이 데이터를 저장하는 가장 작은 단위이다. 운영 체제는 이런 파일 시스템을 사용하여 데이터를 저장하고 검색한다. 

> ex) Windows : `NTFS`, Linux : `ext`

`분산 파일 시스템`(Distributed File System, DFS)는 클러스터 노드에 분산된 대용량 파일을 저장할 수 있는 파일 시스템이다. 클라이언트에게 파일은 로컬에 존재하는 것 처럼 보이겠지만 실제로는 클러스터를 통해 물리적으로 분산된 파일들에 대한 논리적인 뷰를 제공하는 것이다.

> ex) 구글 파일 시스템(Google File System, `GFS`) , 하둡 분산 파일 시스템(Hadoop Distributed File System, `HDFS`)

---

### 3. NoSQL

NoSQL 데이터베이스는 `반정형`, `비정형` 데이터를 수용할 수 있도록 설계되었으며, 높은 확장성과 결함 포용성을 가진 `비관계형 데이터베이스`이다. SQL이외의 쿼리 언어도 지원한다. 예를 들어, XML 파일을 저장하는 데 최적화 된 NoSQL 데이터베이스 XQuery를 쿼리 언어로 사용한다. 

---

### 4. 샤딩

`샤딩(Sharding)`이란 대규모의 데이터 세트를 `샤드(Shard)`라 불리는 더 작고 관리하기 쉬운 데이터 세트로 `수평 분할`하는 프로세스를 말한다. 각 샤드는 분리된 노드에 저장되며 각 노드는 `자신에게 저장된 데이터만 담당`한다. 각 샤드는 `공통의 스키마`를 공유하며 모든 샤드를 모으면 전체 데이터 세트가 된다. 샤딩을 사용하면 여러 노드에 처리 작업량을 분산시켜 `수평 확장성`을 확보할 수 있다. 각 노드는 전체 데이터 집합의 일부만을 담당하므로 데이터를 읽거나 쓰는 데 걸리는 시간이 크게 감소한다. 

> `수평 스케일링`은 기존 자원과 유사하거나 더 많은 용량을 가진 리소스를 추가하여 시스템의 용량을 늘리는 방법이다. 

1. 각 샤드는 독립적으로, 자신이 담당하는 데이터의 특정 부분에 대해 읽기 및 쓰기 작업을 수행할 수 있다.
2. 쿼리에 따라 2개의 샤드에서 데이터를 가져와야 할 수 있다.

샤딩의 이점은 데이터베이스 내의 부분적인 결함을 허용할 수 있다는 것이다.
> 하나의 노드에 장애가 발생하는 경우, 해당 노드에 저장된 데이터만 영향을 받고, 다른 노드의 데이터는 그것과 무관하게 다룰 수 있다.

`여러 샤드`의 데이터가 필요한 쿼리는 `성능 저하`를 초래하기 때문에 일반적으로 같이 액세스되는 데이터를 단일 샤드에 배치하여 `데이터 지역성`을 확보함으로써 이러한 성능 문제를 해결한다.

---

### 5. 복제

`복제(replication)`는 여러 노드에 `레플리카(replica)`라고 하는 데이터 세트의 복사본을 저장하는 것이다.
동일한 데이터가 다양한 노드에 복제되기 때문에 복제는 확장성과 가용성을 제고앟ㄴ다. 개별 노드에 장애가 발생해도 데이터가 손실되지 않도록 하기 때문에 `결함 포용성`을 얻을 수 있다. 

+ 마스터 슬레이브 (Master-Slave)
+ 피어 투 피어 (Peer-to-Peer)

#### 5-1) 마스터 슬레이브 

모든 데이터는 `마스터 노드`에 써진다. 데이터가 마스터 노드에 저장되면 데이터는 여러 슬`레이브 노드`로 복제된다. 추가, 수정 및 삭제를 포함한 모든 외부 `쓰기` 작업 처리는 마스터 노드에서만 발생하고, `읽기` 작업 처리는 어떤 슬레이브 노드에서도 수행할 수 있다. 

`읽기` 요청이 증가해도 수평 스케일링에 `슬레이브 노드`를 추가하여 처리할 수 있다. 
반면 `쓰기` 작업의 경우, 모든 `쓰기` 작업이 `마스터 노드`에 의해서만 조정되기때문에 `쓰기` 양이 증가함에 따라 성능이 저하 된다. 

+ 읽기 작업의 비일관성
> `마스터 노드`의 데이터가 `슬레이브 노드`에 복사되기 전에 노드를 `읽어` 들이면 문제가 발생할 수 있다.
> 대부분의 슬레이브 노드에 동일한 버전의 데이터가 포함되어 있으면 읽기가 일관된 것으로 선언하는 `투표 시스템`을 구현할 수 도 있다.
> 슬레이브 노드 간에 `안정적`이고 `빠른` `통신 메커니즘`이 필요하다.

#### 5-2) 피어 투 피어

모든 노드가 `동일한 수준`에서 작동한다. `피어`라 불리는 각 노드는 읽기와 쓰기 작업을 똑같이 처리할 수 있다.
여러 피어 간에 동일한 데이터를 `동시`에 `업데이트`함으로써 `비일관성` 문제가 쉽게 발생한다. 

+ `비관적 동시성(pessimistic concurrency)` : 비일관성을 `사전에 방지`하는 대응 전략으로, 데이터를 `잠금`하여 사용하는 것 이다. 그러나 잠금이 해제될 때까지 데이터를 사용할 수 없으므로 `가용성에 좋지 않다`.

+ `낙관적 동시성(optimistic concurrency)` : 잠금을 사용하지 않는 `사후 대응` 전략이다. `비일관성`이 발생하더라도 결국 모든 업데이트가 전파되고 나면 일관성이 유지 될 것이라는 사실을 이용한다.

+ 읽기 작업의 비일관성
> `낙관적 동시성`에서 `일부 피어`가 업데이트를 완료하고 다른 일부에서 업데이트가 진행되는 동안 `읽기 작업`이 일관되지 않을 수 있다.
> 대부분의 `피어`에 동일한 버전의 데이터가 포함되어 있으면 읽기가 일관된 것으로 선언하는 `투표 시스템`을 구현할 수 도 있다.
> 슬레이브 노드 간에 `안정적`이고 `빠른` `통신 메커니즘`이 필요하다.

---

### 6. 샤딩 및 복제

`샤딩`과 `복제`를 결합할 수 있다.

+ 샤딩 및 마스터 슬레이브 복제
+ 샤딩 및 피어 투 피어 복제

#### 6-1) 샤딩 및 마스터 슬레이브 복제 결합

`마스터` 자체가 하나의 `샤드`가 되고, 그 마스터에 여러 샤드들이 `슬레이브`가 된다. 이 결과로 `여러 마스터`가 생성될 수 있지만 여전히 `하나의 슬레이브`는 `하나의 마스터`로만 관리할 수 있다. `쓰기의 일관성`은 `마스터 샤드`에 의해 유지된다. 그러나 마스터 샤드가 작동하지 않거나 네트워크 중단이 발생하면 `쓰기` 작업에 대한 `결함 포용성`이 영향을 받는다. 따라서 샤드의 복사본은 여러 슬레이브 샤드에 보관되어 `읽기` 작업에 `확장성`과 `결함 포용성`을 제공한다. 

![이미지](https://Funncy.github.io/assets/img/bigdata/05/2020-05-18-MASTER_SLAVE.png "master slave")

#### 6-2) 샤딩 및 피어 투 피어 복제 결합

각 `샤드`는 여러 피어에 복제되며 각 피어는 `전체 데이터 세트의 일부`만 담당한다. 따라서 총체적으로 `확장성` 및 `결함 포용성`이 향상된다. 마스터와 관련이 없기 때문에 단일 장애 지점이 없으며 `읽기` 및 `쓰기` 작업에 대한 `결함 포용성`이 지원된다.

![이미지](https://Funncy.github.io/assets/img/bigdata/05/2020-05-18-PEER_TO_PEER.png "peer to peer")

---

### 7. CAP 정리

분산 데이터 베이스 시스템은 다음 세가지 속성 중 `두가지만` 제공할 수 있다.

+ `일관성(Consistency)` : 노드에 무관하게 읽기 작업은 `동일한 데이터`를 생성한다.
+ `가용성(Availabilty)` : 읽기 및 쓰기 요청은 항상 `성공` 또는 `실패`의 형태로 확인된다.
+ `분할 포용성(Partition tolerance)` : 클러스터를 여러 개의 사일로(silo)로 분할시키는 `통신 중단`에도 불구하고 `읽기` 및 `쓰기` 요청을 처리한다.

+ `일관성` 및 `가용성` : `일관성`을 유지하기 위해 통신하면 `분할 포용성`을 불가능하다.
+ `일관성` 및 `분할 포용성` : `일관성`을 달성하는 동안 노드를 사용할 수 없다. (`데이터 잠금`)
+ `가용성` 및 `분할 포용성` : 노드 간 데이터 `통신` 요구사항으로 인해 `일관성`을 보장 할 수 없다.

그러므로 일반적으로 `CAP` 중 `C+P (일관성, 분할 포용성)` 또는 `A+P (가용성, 분할 포용성)`를 선택한다. 시스템의 요구사항에 따라 어떤 특성을 선택할지가 결정된다.

---

### 8. ACID

`ACID`는 트랜잭션 관리와 관련된 데이터베이스 설계 원리이다.

+ `원자성(Atomicity)` : 모든 작업이 항상 완전히 성공하거나 완전히 실패한다. 부분적인 성공이 존재 하지 않는다. (부분만 성공시 처음으로 돌려놓는다.)
+ `일관성(Consistency)` : 스키마의 조건에 준수하는 데이터만 기록하여 항상 일관된 상태를 유지하도록 한다.
+ `고립성(Isolation)` : 트랜잭션 결과가 완료될 때까지 다른 작업에서 확인할 수 없도록 한다.
+ `지속성(Durability)` : 작업 결과가 영구적으로 지속된다. 트랜잭션이 실행된 후에는 다시 되돌릴 수 없다.

`일관성`을 유지하기 위해 `데이터 잠금` 애플리케이션을 통한 `비관적 동시성`을 활용하는 트랜잭션 관리 스타일이다.
ACID는 관계형 데이터베이스 관리 시스템에 의해 관리되는 데이터베이스 트랜잭션 관리에 대한 전통적인 접근 방법이다.

---

### 9. BASE

`분산 기술을 사용하는 데이터베이스` 시스템을 설계하는데 사용되는 원리이다.
데이터베이스가 `BASE`를 지원하면 일관성보다 가용성이 좋아진다. CAP 관점에서 `A+P (가용성, 분할 포용성)`를 만족하는 것이다. 낙관적 동시성을 활용한다.

+ `이용 가능한(Basically Available)` : 데이터베이스는 요청된 데이터 또는 `성공/실패` 알림의 형태로 클라이언트의 요청을 `항상 확인`한다. 네트워크 장애로 인해 `분할`되었어도 `이용이 가능`하다.
+ `소프트 상태(Soft state)` : `소프트 상태`는 데이터를 읽어 들일 때 데이터베이스가 `일관성 없는 상태`에 있을 수 있음을 의미 한다. 동일한 데이터가 다시 요청된 경우 결과가 변경될 수 있다. 
+ `궁극적 일관성(Eventual consistency)` : `모든 노드`에 변경 사항이 전파되었을 때에야 데이터베이스는 `일관성`을 유지한다. `궁극적 일관성 상태`에 도달하는 동안에는 `소프트 상태`에 머물러 있다. 

---

### 10. AICD vs BASE

데이터 잠금으로 가용성을 희생하는 대신 그 즉시 일관성을 보장하는 ACID와는 달리, BASE는 가용성을 강조한다. 일관성에 어느 정도 융통성을 부여하는 이 접근 방식은 BASE 호환 데이터베이스에 일관성 없는 결과를 제공하지만 대기 시간이 없이 여러 클라이언트에 서비스를 제공할 수 있게 한다. 그러나 일관성이 부족하면 문제가 발생되는 트랜잭션 시스템에는 유용하지 않다.

> ACID : 은행 계좌 관리 등
> BASE : 소셜 네트워크 등

---

- 출처 [빅데이터 기초 개념,동인,기법]
