---
layout: post
title: "[Bigdata] -  빅데이터 기초 06 : 빅데이터 처리에 대한 개념 "
subtitle:   "Bigdata - 빅데이터 기초"
categories: ml
tags: ml bigdata
comments: true
---

---

### 1. 병렬 데이터 처리

병렬 데이터 처리는 `하나의 큰 작업`을 구성하는 여러 하위 작업의 `동시 처리` 개념이다. 목적은 `하나의 큰 작업`을 여러 작은 작업들로 분할하여 `동시에 작업`함으로써 `수행 시간을 줄이는 것`이다. 

---

### 2. 분산 데이터 처리

분산 데이터 처리는 동일하게 `분할-정복(divide and conquer)` 원리가 적용된다는 점에서 병렬 데이터 처리와 매우 연관성이 높다. 그러나 분산 데이터 처리는 `물리적으로 분할`되어 있는 장치들이 네트워크화되어 하나의 `클러스터`를 이룬 형태에서만 이루어진다. 

---

### 3. 하둡

`하둡(Hadoop)`은 대규모의 데이터를 저장하고 처리하기 위한 `오픈소스 프레임워크`로, 별도의 하드웨어 없이 범용 하드웨어로 구성이 가능하다. 하둡은 `맵리듀스` 처리 프레임워크를 수행한다.

---

### 4. 작업부하 처리

빅데이터에서의 작업부하 처리는 `일정 시간 내에 처리`되는 `데이터의 양`과 `특성`으로 정의된다.

+ 4-1) 일괄 형식
+ 4-2) 트랜잭션 형식

##### 4-1) 일괄 형식

`오프라인 처리`라고도 알려져 있는 일괄 처리는 데이터를 `일괄적`으로 처리함으로써 주로 `지연을 야기`하고 결과적으로 응답 시간을 늘리는 특성을 가지고 있따. 많은 양의 데이터를 `순차적`으로 읽거나 쓰는 작업과 읽기 혹은 쓰기 `쿼리들의 묶음`으로 구성되어 있다. 

> 쿼리는 여러 번의 조인 연산들로 구성되거나 복잡해질 수 있다. `온라인 분석 처리 (OLAP)` 시스템은 워크로드를 주로 `일괄적`으로 처리한다. 

##### 4-2) 트랜잭션 형식

`온라인 처리`라고도 알려져 있다. 데이터가 `지연없이 상호적`으로 처리되어 결과적으로 응답에 소요되는 대기 시간이 짧다.

> `온라인 트랜잭션 처리 (OLTP)` 와 운영 시스템이 이 처리 방식을 사용하는 범주에 속하며, `읽기`보다는 주로 `쓰기` 작업에 초점이 맞춰져 있다. 트랜잭션 워크로드는 BI와 보고 워크로드에 비해 적은 조인 연산을 포함하는 무작위의 읽기/쓰기 작업으로 구성되어 있다.

> 1대의 장치 성능을 높이는 방식을 `수직적 확장 (scale up)` 이라고 하고, 낮은 성능의 장치를 여러 대 사용하는 것을 `수평적 확장 (scale out) `이라 한다.

---

### 5. 클러스터

`클러스터링`은 매우 `높은 확장/축소 가능성`을 가지기 떄문에, 큰 데이터 세트를 작은 데이터 세트로 `분할`하고 분산된 형태로 `병렬`적으로 처리하는 빅데이터 처리 방식에 이상적인 환경을 제공한다. `클러스터`의 추가적인 이점은 `물리적으로 분리된 노드`로 이루어져 있기 때문에 고유의 `중복성`과 `결함 포용성`을 제공한다는 것이다. 데이터 세트는 `일괄 방식`으로 처리될 수도 있고 `실시간 방식`으로 처리될 수도 있다.

---

### 6. 일괄 처리 방식

오프라인에서 일괄적으로 처리되며 반응 시간은 분 단위에서 시간 단위로 다양해질 수 있다. 또한 데이터는 반드시 처리되기 전에 디스크에 영구적으로 저장되어야 한다. 빅데이터 처리는 대부분은 일괄 방식으로 진행된다. 실시간 방식에 비해 상대적으로 간단하고, 시작하기 쉬우며 저렴하기 때문이다. 

###### 6-1) 맵리듀스를 사용한 일괄 처리

맵리듀스는 일괄 처리 프레임워크를 실행하는 데 널리 사용된다. 분할-정복 원칙에 기반하므로 내재된 결함 포용성과 중복성을 제공할 수 있다. 스키마가 없는 데이터 세트를 다루는 데에도 사용될 수 있다.

전통적으로 데이터 처리를 위해서는 저장 노드에 있는 데이터를 처리 노드로 이동시켜야 한다. 큰 데이터 세트의 경우, 데이터를 이동시키는 것이 실제 처리보다 더 많은 오버헤드를 발생시킬 수 있다.

맵리듀스를 사용하면 처리 알고리즘이 저장 노드에서 병렬로 실행되므로 데이터를 이동시킬 필요가 없다. 네트워크 대역폭을 절약할 뿐만 아니라 훨씬 빠르기 때문에 처리 시간을 크게 단축시킨다.

###### 6-2) 맵과 리듀스 작업

단일 처리 수행은 맵리듀스 잡(job)으로 알려져 있다. 각각의 맵리듀스 잡은 맵(map)작업과 리듀스(reduce)작업으로 구성되며 여러 단계로 구성되어 있다.

맵 작업

+ 맵
+ 결합(선택사항)
+ 분할

리듀스 작업

+ 셔플과 정렬
+ 리듀스

![이미지](https://Funncy.github.io/assets/img/bigdata/06/2020-05-19-MAP_REDUCE.png "map reduce")

###### 6-3) 맵

`맵리듀스`의 첫 번째 단계는 데이터 세트 파일이 여러 개의 `작은 스플릿`들로 나뉘는 맵 단계이다. 각 스플릿은 이들을 구성하는 레코드를 `키-값 쌍` 형태로 파싱한다. 스플릿당 하나의 `매퍼(mapper)`함수와 함께 `맵 함수` 또는 `매퍼`로 전송된다. `맵 함수`는 사용자가 정의한 `로직`을 수행한다. 

`매퍼`는 사용자가 정의한 로직에 따라 각 `키-값 쌍`을 처리하고 출력으로 `키-값 쌍`을 생성한다. 스플릿의 모든 레코드가 처리된 후의 출력은 동일한 키에 대해 여러 `키-값 쌍`이 존재 할수 있는 `키-값 쌍`의 목록이다. 

> 유의할 점은, 입력 `키-값 쌍`의 경우, 매퍼가 출력 `키-값 쌍`을 생성하지 않거나`(필터링)` 여러 `키-값 쌍`을 생성할 수 있다는 점이다.`(역다중화)`

###### 6-4) 결합

일반적으로 맵 함수의 출력은 리듀스 함수에 의해 직접 처리된다. 그러나 맵 함수와 리듀스 함수는 다른 노드에서 실행된다. 그렇기 때문에 데이터 이동이 필요하다. 큰 데이터 세트를 사용하면 데이터 이동하는데 걸리는 시간이 실제 맵 작업과 리듀스 작업을 처리하는 시간보다 더 길어질 수 있는데 이러한 이유로 맵 함수에서 출력이 처리되기 전에 이를 요약해주는 결합 함수의 실행 옵션을 제공한다. 

결합 함수(결합자)는 기본적으로 매퍼(맵 함수)와 동일한 노드에서 매퍼의 출력을 지역적으로 그룹화하는 리듀서 함수이다. 매퍼의 출력에서 나온 키들의 값을 결합시킨다. 결합 단계는 최적화 단계일 뿐이므로, 맵리듀스 엔진에서 호출되지 않을 수도 있다.

##### 6-5) 분할

2개 이상의 리듀서가 관련된 경우, 분할 단계에서는 분할기가 매퍼 또는 결합자의 출력을 파티션으로 분할하여 리듀서 인스턴스로 만든다. 파티션의 수는 리듀서의 수와 같다. 파티션 함수는 맵 작업 중 마지막 단계에서 수행되고, 특정 파티션 인덱스를 반환한다.

##### 6-6) 셔플과 정렬

리듀스 작업의 첫 번째 단계이자, 네트워크를 통해 리듀스 작업 실행하는 노드로 복사되는데, 이를 셔플링이라고 한다. 각 분할기에서 출력된 키-값 목록에는 동일한 키가 여러 번 포함될 수 있다.

다음으로, 맵리듀스 엔진은 키-값 쌍을 키 기준으로 자동으로 그룹화하고 정렬하여 같은 키가 모여 있는 정렬된 목록을 출력한다. 특정 키에 대해서 값을 그룹화하고 정렬하는 방법은 사용자가 정의할 수 있다. 이 병합은 그룹당 하나의 키-값 쌍을 생성한다. 여기서 키는 그룹 키이고 값은 모든 그룹 값 목록이다.

###### 6-7) 리듀스

리듀스 함수(리듀서)에 지정된 사용자 정의 로직에 따라 리듀서는 입력을 추가로 요약하거나, 변경 없이 그대로 출력을 내보낸다. 값 부분에 저장된 값들의 목록이 처리되어 새로운 키-값 쌍으로 기록된다. 

매퍼와 마찬가지로 리듀서는 입력된 키-값 쌍에 대해서 출력 키-값 쌍을 생성하지 않거나(필터링) 여러 키-값 쌍을 생성할 수 있다(역다중화). 리듀서의 출력은 분할된 파일로 작성된다(리듀서당 하나의 파일). 맵리듀스 작업의 전체 출력 결과를 보려면 모든 파일 부분을 통합해야 한다.

![이미지](https://Funncy.github.io/assets/img/bigdata/06/2020-05-19-MAP_REDUCE_2.png "map reduce 2")

##### 6-8) 맵리듀스 알고리즘의 이해

##### 작성중...

---



---

- 출처 [빅데이터 기초 개념,동인,기법]