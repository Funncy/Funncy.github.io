---
layout: post
title: "[Bigdata] -  빅데이터 기초 06 : 빅데이터 처리에 대한 개념 "
subtitle:   "Bigdata - 빅데이터 기초"
categories: ml
tags: ml bigdata
comments: true
---

---

### 1. 병렬 데이터 처리

병렬 데이터 처리는 `하나의 큰 작업`을 구성하는 여러 하위 작업의 `동시 처리` 개념이다. 목적은 `하나의 큰 작업`을 여러 작은 작업들로 분할하여 `동시에 작업`함으로써 `수행 시간을 줄이는 것`이다. 

---

### 2. 분산 데이터 처리

분산 데이터 처리는 동일하게 `분할-정복(divide and conquer)` 원리가 적용된다는 점에서 병렬 데이터 처리와 매우 연관성이 높다. 그러나 분산 데이터 처리는 `물리적으로 분할`되어 있는 장치들이 네트워크화되어 하나의 `클러스터`를 이룬 형태에서만 이루어진다. 

---

### 3. 하둡

`하둡(Hadoop)`은 대규모의 데이터를 저장하고 처리하기 위한 `오픈소스 프레임워크`로, 별도의 하드웨어 없이 범용 하드웨어로 구성이 가능하다. 하둡은 `맵리듀스` 처리 프레임워크를 수행한다.

---

### 4. 작업부하 처리

빅데이터에서의 작업부하 처리는 `일정 시간 내에 처리`되는 `데이터의 양`과 `특성`으로 정의된다.

+ 4-1) 일괄 형식
+ 4-2) 트랜잭션 형식

##### 4-1) 일괄 형식

`오프라인 처리`라고도 알려져 있는 일괄 처리는 데이터를 `일괄적`으로 처리함으로써 주로 `지연을 야기`하고 결과적으로 응답 시간을 늘리는 특성을 가지고 있따. 많은 양의 데이터를 `순차적`으로 읽거나 쓰는 작업과 읽기 혹은 쓰기 `쿼리들의 묶음`으로 구성되어 있다. 

> 쿼리는 여러 번의 조인 연산들로 구성되거나 복잡해질 수 있다. `온라인 분석 처리 (OLAP)` 시스템은 워크로드를 주로 `일괄적`으로 처리한다. 

##### 4-2) 트랜잭션 형식

`온라인 처리`라고도 알려져 있다. 데이터가 `지연없이 상호적`으로 처리되어 결과적으로 응답에 소요되는 대기 시간이 짧다.

> `온라인 트랜잭션 처리 (OLTP)` 와 운영 시스템이 이 처리 방식을 사용하는 범주에 속하며, `읽기`보다는 주로 `쓰기` 작업에 초점이 맞춰져 있다. 트랜잭션 워크로드는 BI와 보고 워크로드에 비해 적은 조인 연산을 포함하는 무작위의 읽기/쓰기 작업으로 구성되어 있다.

> 1대의 장치 성능을 높이는 방식을 `수직적 확장 (scale up)` 이라고 하고, 낮은 성능의 장치를 여러 대 사용하는 것을 `수평적 확장 (scale out) `이라 한다.

---

### 5. 클러스터

`클러스터링`은 매우 `높은 확장/축소 가능성`을 가지기 떄문에, 큰 데이터 세트를 작은 데이터 세트로 `분할`하고 분산된 형태로 `병렬`적으로 처리하는 빅데이터 처리 방식에 이상적인 환경을 제공한다. `클러스터`의 추가적인 이점은 `물리적으로 분리된 노드`로 이루어져 있기 때문에 고유의 `중복성`과 `결함 포용성`을 제공한다는 것이다. 데이터 세트는 `일괄 방식`으로 처리될 수도 있고 `실시간 방식`으로 처리될 수도 있다.

---

### 6. 일괄 처리 방식

`오프라인`에서 일괄적으로 처리되며 반응 시간은 분 단위에서 시간 단위로 다양해질 수 있다. 또한 데이터는 반드시 처리되기 전에 `디스크`에 `영구적으로 저장`되어야 한다. 빅데이터 처리는 `대부분은 일괄 방식`으로 진행된다. 실시간 방식에 비해 상대적으로 `간단하고`, 시작하기 `쉬우며` `저렴`하기 때문이다. 

###### 6-1) 맵리듀스를 사용한 일괄 처리

`맵리듀스`는 `일괄 처리 프레임워크`를 실행하는 데 널리 사용된다. `분할-정복 원칙`에 기반하므로 내재된 `결함 포용성`과 `중복성`을 제공할 수 있다. `스키마가 없는 데이터 세트`를 다루는 데에도 사용될 수 있다.

전통적으로 데이터 처리를 위해서는 저장 노드에 있는 데이터를 처리 노드로 이동시켜야 한다. 큰 데이터 세트의 경우, `데이터를 이동`시키는 것이 실제 처리보다 더 많은 `오버헤드`를 발생시킬 수 있다.

맵리듀스를 사용하면 처리 알고리즘이 저장 노드에서 `병렬로 실행`되므로 `데이터를 이동시킬 필요가 없다`. 네트워크 대역폭을 절약할 뿐만 아니라 훨씬 빠르기 때문에 `처리 시간을 크게 단축`시킨다.

###### 6-2) 맵과 리듀스 작업

단일 처리 수행은 맵리듀스 `잡(job)`으로 알려져 있다. 각각의 맵리듀스 잡은` 맵(map)`작업과 `리듀스(reduce)`작업으로 구성되며 여러 단계로 구성되어 있다.

맵 작업

+ 맵
+ 결합(선택사항)
+ 분할

리듀스 작업

+ 셔플과 정렬
+ 리듀스

![이미지](https://Funncy.github.io/assets/img/bigdata/06/2020-05-19-MAP_REDUCE.png "map reduce")

###### 6-3) 맵

`맵리듀스`의 첫 번째 단계는 데이터 세트 파일이 여러 개의 `작은 스플릿`들로 나뉘는 맵 단계이다. 각 스플릿은 이들을 구성하는 레코드를 `키-값 쌍` 형태로 파싱한다. 스플릿당 하나의 `매퍼(mapper)`함수와 함께 `맵 함수` 또는 `매퍼`로 전송된다. `맵 함수`는 사용자가 정의한 `로직`을 수행한다. 

`매퍼`는 사용자가 정의한 로직에 따라 각 `키-값 쌍`을 처리하고 출력으로 `키-값 쌍`을 생성한다. 스플릿의 모든 레코드가 처리된 후의 출력은 동일한 키에 대해 여러 `키-값 쌍`이 존재 할수 있는 `키-값 쌍`의 목록이다. 

> 유의할 점은, 입력 `키-값 쌍`의 경우, 매퍼가 출력 `키-값 쌍`을 생성하지 않거나`(필터링)` 여러 `키-값 쌍`을 생성할 수 있다는 점이다.`(역다중화)`

###### 6-4) 결합

일반적으로 맵 함수의 출력은 리듀스 함수에 의해 직접 처리된다. 그러나 맵 함수와 리듀스 함수는 다른 노드에서 실행된다. 그렇기 때문에 `데이터 이동`이 필요하다. 큰 데이터 세트를 사용하면 데이터 이동하는데 걸리는 시간이 실제 맵 작업과 리듀스 작업을 처리하는 시간보다 더 길어질 수 있는데 이러한 이유로 맵 함수에서 출력이 처리되기 전에 이를 `요약`해주는 결합 함수의 실행 옵션을 제공한다. 

결합 함수(결합자)는 기본적으로 `매퍼(맵 함수)`와 동일한 노드에서 매퍼의 출력을 지역적으로 `그룹화`하는 `리듀서 함수`이다. 매퍼의 출력에서 나온 `키들의 값을 결합`시킨다. 결합 단계는 `최적화 단계`일 뿐이므로, 맵리듀스 엔진에서 호출되지 않을 수도 있다.

##### 6-5) 분할

`2개 이상의 리듀서`가 관련된 경우, 분할 단계에서는 분할기가 매퍼 또는 결합자의 출력을 `파티션으로 분할`하여 `리듀서 인스턴스`로 만든다. 파티션의 수는 리듀서의 수와 같다. 파티션 함수는 맵 작업 중 마지막 단계에서 수행되고, 특정 파티션 인덱스를 반환한다.

##### 6-6) 셔플과 정렬

리듀스 작업의 첫 번째 단계이자, 네트워크를 통해 리듀스 작업 실행하는 노드로 복사되는데, 이를 `셔플링`이라고 한다. 각 분할기에서 출력된 `키-값 `목록에는 동일한 키가 `여러 번 포함`될 수 있다.

다음으로, 맵리듀스 엔진은 `키-값` 쌍을 키 기준으로 자동으로 `그룹화`하고 `정렬`하여 `같은 키`가 모여 있는 `정렬된 목록`을 출력한다. 특정 키에 대해서 값을 그룹화하고 정렬하는 방법은 사용자가 정의할 수 있다. 이 병합은 그룹당 하나의 `키-값` 쌍을 생성한다. 여기서 키는 그룹 키이고 값은 모든 그룹 값 목록이다.

###### 6-7) 리듀스

`리듀스 함수(리듀서)`에 지정된 사용자 정의 로직에 따라 리듀서는 `입력을 추가로 요약`하거나, 변경 없이 `그대로 출력`을 내보낸다. 값 부분에 저장된 값들의 목록이 처리되어 새로운 `키-값` 쌍으로 기록된다. 

매퍼와 마찬가지로 리듀서는 입력된 `키-값` 쌍에 대해서 출력 `키-값` 쌍을 생성하지 않거나(필터링) 여러 `키-값` 쌍을 생성할 수 있다(역다중화). 리듀서의 출력은 분할된 파일로 작성된다(리듀서당 하나의 파일). 맵리듀스 작업의 전체 출력 결과를 보려면 모든 파일 부분을 통합해야 한다.

![이미지](https://Funncy.github.io/assets/img/bigdata/06/2020-05-19-MAP_REDUCE_2.png "map reduce 2")

##### 6-8) 맵리듀스 알고리즘의 이해

맵리듀스는 분할-정복의 원칙에 따라 작동한다. 

+ `작업 병렬 처리` : `작업`을 여러 개의 `부분 작업`으로 나누고 각 `부분 작업`을 별도의 프로세서에서 실행하여 데이터 처리를 병렬화 하는것을 의미한다.

+ `데이터 병렬 처리` : 데이터 세트를 `여러 개의 데이터 세트`로 나누고 각 부분 데이터 세트를 병렬로 처리하는 데이터 처리의 병렬화를 의미한다. 

`맵리듀스`는 `데이터`를 나누는 `병렬 처리 방식`을 사용한다. 동일한 처리 논리를 가지는 맵 함수가 각각의 `스플릿`마다 자체 인스턴스에 의해 처리된다. 
맵 리듀스에서 연산은 `맵`과 `리듀스` 함수로 나뉜다. `맵` 및 `리듀스` 작업은 `독립적`이며 다른 작업에 관계 없이 수행된다. 맵리듀스 함수의 특성은 `키-값` 쌍의 집합으로 제한된다. 키-값 쌍은 맵 함수가 리듀스 함수와 소통할 수 있는 유일한 방법이다. 

+ 상대적으로 `단순한 알고리즘`을 사용하여 `데이터 병렬 처리`를 적용한 다음 몇 가지 다른 방식으로 집계하여 원하는 결과를 얻을 수 있도록 한다.

+ `데이터 세트 분산` 방식으로 `클러스터`에 분할시켜 여러 맵 함수가 데이터 세트의 여러 `부분 집합`을 병렬로 처리할 수 있도록 한다.

+ `의미 있는 데이터` 단위를 선택할수 있도록 데이터 세트 내의 데이터의 구조를 이해한다.

+ `단일 스플`릿 내의 데이터만 사용 가능하므로, 맵과 리듀스 함수가 전체 데이터 세트에 `종속되지 않도록` 한다.

+ `리듀스 함수`는 `맵 함수`에서 나온 `키-값` 쌍을 처리하기 때문에 `올바른 키`를 내보내야 한다. 

+ 각 `리듀스 함수`의 출력이 최종 `출력`이 되기 때문에 `리듀스 함수`에서 `올바른 키`를 내보내야 한다.

---

### 7. 실시간 처리 방식

`실시간 방식`에서는 데이터가 `메모리 내`에서 처리된다. 응답 시간은 일반적으로 1초에서 1분 이하이다. 빅데이터 세트의 속도 특성을 보여준다. 데이터가 연속적으로 또는 간격을 두고 도착하므로 이벤트 또는 스트림 처리라고 한다. 일반적으로 크기가 작지만, 연속적 특성으로 인해 매우 큰 데이터 세트가 생성된다. 

##### 7-1) 속도 일관성 용량(SCV)

`CAP` 정리는 주로 분산 데이터 저장과 관련이 있지만 `SCV` 원칙은 분산 데이터 처리와 관련이 있다. 다음 세가지 요구사항 중 두가지만 지원하도록 설계될 수 있다.

+ `속력` : 데이터를 얼마나 `빨리 처리`할 수 있는지를 나타낸다. `실시간 분석`이 `일괄 분석`보다 비교적 빠르게 처리된다. 일반적으로 데이터를 메모리에서 캡처하는데 걸리는 시간은 제외되며 실제 데이터 처리에만 집중한다.

+ `일관성` : 결과의 `정확성`과 `정밀성`을 의미한다. 

+ `용량` : `데이터의 양`을 나타낸다. 빅데이터의 속력 특성으로 인해 데이터 세트가 빠르게 증가하면, 방대한 양의 데이터를 분산된 방식으오 처리해야 할 필요성이 대두된다. 전체적으로, 속력과 일관성을 모두 유지하면서 이러한 방대한 데이터를 처리하는 것은 불가능하다.

`속력`과 `일관성`이 요구되면 많은 양의 데이터 처리가 `속력`을 늦추게된다. `일관성` 및 `용량`이 필요한 경우, 많은 데이터 때문에 `속력`을 높일 수 없다. `속력`과 `용량`이 필요한 경우, `일관성`을 떨어뜨리는 샘플링 방법을 사용할 수 밖에 없다. 

`실시간 데이터 처리`는 데이터를 디스크에 저장하는 대신 먼저 `메모리`에서 처리하고, 나중에 사용하거나 보관하기 위해서 디스크에 저장한다. 그러므로 `인메모리` 저장 장치(IMDG 또는 IMDB)를 사용해야한다. 하드디스크 I/O 대기 시간 없이 `실시간으로 데이터를 처리`할 수 있다. 

###### 7-2) 이벤트 스트림 처리 (ESP)

`단일 소스`로부터 시간에 따라 정렬된 이벤트의 수신 스트림이 연속적으로 분석된다. 분석은 간단한 쿼리 또는 대부분이 수식을 기반으로 이루어질 수 있다. 

###### 7-3) 복잡 이벤트 처리 (CEP)

`서로 다른 소스`에서 오는 다양한 실시간 이벤트가 패턴 및 작업 시작 탐지를 위해 동시에 분서된다. 규칙 기반 알고리즘 및 통제 기법을 적용함으로써, 교차 편집된 복잡한 이벤트의 패턴을 발견한다. 풍부한 분석 기능을 제공한다. 그러나 결과적으로 수행 속도가 저하될 수 있다. 

###### 7-4) 실시간 빅데이터 처리와 SCV

실시간 빅데이터 처리 시스템을 설계하는 동안 `SCV` 원칙을 염두에 두어야 한다. `높은 데이터 용량(V)`는 필수다. 

+ `완 실시간` : `빠른 응답(S)`가 필요하므로 `대용량 데이터(V)`를 메모리에서 처리해야하는 경우 `일관성(C)`가 저하된다. `샘플링` 또는 `근사화 기법`을 사용해야 하며, 결과적으로 정확도는 떨어지지만 적절한 정밀도를 가지도록 적절한 시간 내에 생성한다. 

+ `근 실시간` : `적절히 빠른 응답(S)`만이 필요하므로 `대용량 데이터(V)`를 메모리에서 처리해야 하는 경우 `일관성(C)`를 보장할 수 있다. 전체 데이터 세트를 이용할 수 있으므로 완실시간 시스템과 비교할때 결과가 더 정확하다. 

`속력(S)`와 `일관성(C)`는 반비례한다.

###### 7-5) 실시간 빅데이터 처리와 맵리듀스

`맵리듀스`는 일반적으로 `실시간 처리에 적합하지 않다`. `맵리듀스`는 디스크에 저장된 많은 양의 데이터를 `일괄적으로 처리`하기 위한 것이다. `맵리듀스`는 점진적으로 데이터처리를 할 수 없으며 `전체 데이터 집합`만 처리할 수 있다. 

그러나 `몇 가지 전략`으로 실시간에 가까운 빅데이터 처리 시나리오에서 `맵리듀스`를 사용할 수 있다. 
+ `인메모리 저장 장치`를 사용하여 `맵리듀스` 작업으로 구성된 `대화형 쿼리`에 대한 입력으로 사용되는 데이터를 저장하는 것이다. 
+ 비교적 `작은 데이터 세트`에서 `빈번한 간격`, 예를 들어 매 5분마다 실행되도록 구성된 일괄 처리 `맵리듀스` 작업을 배포할 수 있다. 
+ `온디스크 저장 장치` 데이터 세트에 대해 `맵리듀스` 작업을 `지속적으로 실행`하여, `대화형 쿼리` 처리를 위해 새로 도착한 `인메모리` 스트리밍 데이터의 작은 용량 분석 결과와 `결합`할 수 있는 구체화된 보기를 생성한다.

`스파크`, `스톰`, `테즈`와 같은 오픈소스 아파치 프로젝트는 진정한 `실시간 빅데이터 처리` 기능을 제공하며 새로운 세대의 실시간 처리 솔루션의 기초가 된다.

---

- 출처 [빅데이터 기초 개념,동인,기법]